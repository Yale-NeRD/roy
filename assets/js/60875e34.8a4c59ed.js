"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[661],{7315:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>u});var s=n(4848),i=n(8453);const a={sidebar_position:1},r="Roy Tutorial",o={id:"tutorial",title:"Roy Tutorial",description:"Let's get started with Roy and learn how to program with mutable remote objects!",source:"@site/docs/tutorial.md",sourceDirName:".",slug:"/tutorial",permalink:"/roy/docs/tutorial",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar"},l={},u=[{value:"Simple distributed counter example (to compute \u03c0)",id:"simple-distributed-counter-example-to-compute-\u03c0",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Basic use of Roy data structures",id:"basic-use-of-roy-data-structures",level:3},{value:"Collecting results",id:"collecting-results",level:3},{value:"Putting things together",id:"putting-things-together",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"roy-tutorial",children:"Roy Tutorial"}),"\n",(0,s.jsx)(t.p,{children:"Let's get started with Roy and learn how to program with mutable remote objects!"}),"\n",(0,s.jsxs)(t.p,{children:["Roy provides built-in classes for remote but ",(0,s.jsx)(t.em,{children:"mutable"})," object that can be used in Ray tasks. Currently, they are ",(0,s.jsx)(t.code,{children:"RoyList"}),", ",(0,s.jsx)(t.code,{children:"RoyDict"}),", and ",(0,s.jsx)(t.code,{children:"RoySet"}),"."]}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsxs)(t.p,{children:["We assume that you have a running Ray cluster. If you don't have one, please refer to the ",(0,s.jsx)(t.a,{href:"https://docs.ray.io/en/latest/index.html",children:"Ray documentation"})," to set up a Ray cluster."]}),(0,s.jsx)(t.p,{children:"You can check the status as follows in the terminal:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"ray status\n"})}),(0,s.jsxs)(t.p,{children:["We also assume that you already installed the ",(0,s.jsx)(t.code,{children:"roy-on-ray"})," package. If not, please install it via pip:"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"pip install roy-on-ray\n"})})]}),"\n",(0,s.jsx)(t.h2,{id:"simple-distributed-counter-example-to-compute-\u03c0",children:"Simple distributed counter example (to compute \u03c0)"}),"\n",(0,s.jsxs)(t.p,{children:["Let's take a look at a simple example of using ",(0,s.jsx)(t.code,{children:"RoyDict"})," to count the frequency of words in a list.\nWe will use the Monte Carlo method to estimate the value of \u03c0."]}),"\n",(0,s.jsx)(t.h3,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsx)(t.p,{children:"Let's first import required libraries including Roy and Ray."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"import random\nimport ray\nfrom roy_on_ray import RoyDict\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Inside our main function, we will first initialize Ray and define a counter object as a ",(0,s.jsx)(t.code,{children:"RoyDict"}),".\nEach key will be the task ID and the value will be the number of samples that fall inside the unit circle."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"    # Number of workers\n    num_tasks = 8\n\n    # Initialize Ray\n    ray.init()\n\n    # Create a container to store the results\n    counters = RoyDict({i: 0 for i in range(num_tasks)}, num_chunks=num_tasks)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"basic-use-of-roy-data-structures",children:"Basic use of Roy data structures"}),"\n",(0,s.jsxs)(t.p,{children:["To print out values in the Roy-provided data structures, developers need to use the ",(0,s.jsx)(t.code,{children:"with"})," statement to access the data. It will internally lock the object and ensures data consistency (only a single process can access the data at a time)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'    # Print the initial state\n    # Note) Expensive operation since it fetches all remote objects to print\n    with counters as container:\n        print("Counters:", container)\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now we define ray tasks for Monte Carlo sampling. Note that we are collecting the results in two ways: one is by updating the shared object and the other is by returning the value."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"    # Define function to compute pi\n    @ray.remote\n    def sampling_task(task_id, num_samples, result_container):\n        inside = 0.\n        for _ in range(num_samples):\n            x = random.uniform(-1, 1)\n            y = random.uniform(-1, 1)\n            if x**2 + y**2 <= 1:\n                inside += 1\n\n        # Collecting values via mutable object\n        with result_container as container:\n            container[task_id] = inside\n\n        # Collecting values via return\n        return inside\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"For now, since we are doing a single round of result reporting, there might be no significant difference between those two ways of collecting the results. However, for more complex use cases, using mutable objects is useful to simplify your operations. For example, if you want to update the progress of each task periodically in the middle of a long-running task, you can update the progress/status via mutable objects (or define a Ray Actor that exposes remote function calls for such updates)."})}),"\n",(0,s.jsx)(t.h3,{id:"collecting-results",children:"Collecting results"}),"\n",(0,s.jsx)(t.p,{children:"Finally, we launch the tasks, collect the results, and compare the results from the two methods."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'    # Launch tasks\n    num_samples_per_task = 10000\n    results = [sampling_task.remote(id, num_samples_per_task, counters) for id in range(num_tasks)]\n\n    # Results from returns\n    pi_estimate = 4 * sum(ray.get(results)) / (num_tasks * num_samples_per_task)\n\n    # Results from the mutable shared object\n    with counters as container:\n        pi_estimate_roy = 4 * sum(counters.values()) / (num_tasks * num_samples_per_task)\n\n    # Print the results for comparison\n    print("Estimated pi using ray returns:", pi_estimate)\n    print("Estimated pi using roy variables:", pi_estimate_roy)\n'})}),"\n",(0,s.jsx)(t.h3,{id:"putting-things-together",children:"Putting things together"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import random\nimport ray\nfrom roy_on_ray import RoyDict\n\nif __name__ == \'__main__\':\n    # Number of workers\n    num_tasks = 8\n\n    # Initialize Ray\n    ray.init()\n\n    # Create a container to store the results\n    counters = RoyDict({i: 0 for i in range(num_tasks)}, num_chunks=num_tasks)\n\n    # Print the initial state\n    # Note) Expensive operation since it fetches all remote objects to print\n    with counters as container:\n        print("Counters:", container)\n    # NOTE) The following will cause error (sometime not immeidately but eventually)\n    # print("Counters:", counters)\n\n    # Define function to compute pi\n    @ray.remote\n    def sampling_task(task_id, num_samples, result_container):\n        inside = 0.\n        for _ in range(num_samples):\n            x = random.uniform(-1, 1)\n            y = random.uniform(-1, 1)\n            if x**2 + y**2 <= 1:\n                inside += 1\n        # Collecting values via mutable object\n        with result_container as container:\n            container[task_id] = inside\n        # Collecting values via return\n        return inside\n\n    # Launch tasks\n    num_samples_per_task = 10000\n    results = [sampling_task.remote(id, num_samples_per_task, counters) for id in range(num_tasks)]\n\n    # Results from returns\n    pi_estimate = 4 * sum(ray.get(results)) / (num_tasks * num_samples_per_task)\n\n    # Results from the mutable shared object\n    with counters as container:\n        pi_estimate_roy = 4 * sum(counters.values()) / (num_tasks * num_samples_per_task)\n\n    # Print the results for comparison\n    print("Estimated pi using ray returns:", pi_estimate)\n    print("Estimated pi using roy variables:", pi_estimate_roy)\n'})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);